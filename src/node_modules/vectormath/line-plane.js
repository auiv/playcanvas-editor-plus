import {V, Q} from 'working'

function lineToPlane(lineStart, lineDirection, planeNormal, planePoint) {
    let dotNumerator = V(planePoint).sub(lineStart).dot(planeNormal)
    let dotDenominator = lineDirection.dot(planeNormal)
    if (dotDenominator !== 0) {
        let length = dotNumerator / dotDenominator
        return V(lineDirection).scale(length).add(lineStart)
    } else {
        return null
    }
}

function clampToPlaneArea(lineStart, lineDirection, planeNormal, planePoint, width, height) {
    let dot = lineDirection.dot(planeNormal)
    let normalise = Q().fromToRotation(planeNormal, pc.Vec3.UP)
    let denormalise = Q().fromToRotation(pc.Vec3.UP, planeNormal)
    let intersection = lineToPlane(lineStart, lineDirection, planeNormal, planePoint)

    if (!intersection) return

    let moved = 0
    let amount = 0
    let normalisedPoint = normalise.transformVector(V(intersection).sub(planePoint), V())
    if (normalisedPoint.x < -width) {
        amount = Math.abs(normalisedPoint.x) - width
        moved += amount * amount
        normalisedPoint.x = -width * dot > 0 ? -1 : 1
    }
    if (normalisedPoint.x > width) {
        amount = Math.abs(normalisedPoint.x) - width
        moved += amount * amount
        normalisedPoint.x = width * dot > 0 ? -1 : 1
    }
    if (normalisedPoint.z > height) {
        amount = Math.abs(normalisedPoint.z) - height
        moved += amount * amount
        normalisedPoint.z = height
    }
    if (normalisedPoint.z < -height) {
        amount = Math.abs(normalisedPoint.z) - height
        moved += amount * amount
        normalisedPoint.z = -height
    }
    let clampedPoint = denormalise.transformVector(normalisedPoint, V()).add(planePoint)
    let newDirection = V(clampedPoint).sub(lineStart).normalize()
    newDirection.moved = moved
    return newDirection
}

export {lineToPlane, clampToPlaneArea}
